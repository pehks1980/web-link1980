
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>endpoint: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">github.com/pehks1980/go_gb_be1_kurs/web-link/internal/app/endpoint/api-error.go (100.0%)</option>

				<option value="file1">github.com/pehks1980/go_gb_be1_kurs/web-link/internal/app/endpoint/link-middle.go (78.7%)</option>

				<option value="file2">github.com/pehks1980/go_gb_be1_kurs/web-link/internal/app/endpoint/link-validate.go (84.6%)</option>

				<option value="file3">github.com/pehks1980/go_gb_be1_kurs/web-link/internal/app/endpoint/link.go (65.4%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">package endpoint

import (
        "encoding/json"
        "net/http"
)

// Errors - json error api
type Errors struct {
        Errors []ErrorEl `json:"errors"`
}

// ErrorEl - json array
type ErrorEl struct {
        Code    uint64 `json:"code"`
        Message string `json:"message"`
}

var (
        apiErrorList = map[uint64]string{
                1:   "Token has expired time",
                2:   "Unknown token",
                3:   "Access/Refresh token is lost",
                4:   "The shortlink name must be provided.",
                5:   "The shortlink with the specified name already exists",
                6:   "The shortlink with the specified name does not exist",
                7:   "Please provide refresh token, or authenticate again",
                8:   "No uid (user id), please set uid",
                9:   "Unknown content type",
                10:  "Internal repo problem",
                11:  "No shorturl in data",
                400: "Bad request",
                401: "Unauthorized",
                402: "Payment required",
                403: "Forbidden",
                404: "Not found",
                405: "Method not allowed",
        }
)

// ResponseAPIError - reply to api when some error happened when accessing api
func ResponseAPIError(w http.ResponseWriter, code uint64, status int) <span class="cov8" title="1">{
        var errorsjson = Errors{}
        errorel := ErrorEl{Code: code, Message: apiErrorList[code]}
        errorsjson.Errors = append(errorsjson.Errors, errorel)

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status) //has to be called first!!!!
        _ = json.NewEncoder(w).Encode(errorsjson)

}</span>
</pre>

		<pre class="file" id="file1" style="display: none">package endpoint

import (
        "context"
        "fmt"
        "log"
        "net/http"
        "regexp"
        "strings"
        "time"

        "github.com/dgrijalva/jwt-go"
)

// lint error fix - did not like string type
type ctxKey struct{}

// LoggingMiddleware - logs any request to api
func LoggingMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                start := time.Now()
                //вызов следующего хендлера в цепочке
                next.ServeHTTP(w, r)
                props, _ := r.Context().Value(ctxKey{}).(jwt.MapClaims)
                UID := fmt.Sprintf("%v", props["uid"])
                log.Printf("request: %s %s, user: %s - %v\n",
                        r.Method,
                        r.URL.EscapedPath(),
                        UID,
                        time.Since(start),
                )
        }</span>)
}

// GenJWTWithClaims - generate jwt tokens pair
func GenJWTWithClaims(uidText string, tokenType int) (string, error) <span class="cov8" title="1">{
        mySigningKey := []byte("AllYourBase")

        type MyCustomClaims struct {
                UID string `json:"uid"`
                jwt.StandardClaims
        }
        // type 0  access token is valid for 24 hours
        var timeExpiry = time.Now().Add(time.Hour * 24).Unix()
        var issuer = "weblink_access"

        if tokenType == 1 </span><span class="cov8" title="1">{
                // refresh token type 1 is valid for 5 days
                timeExpiry = time.Now().Add(time.Hour * 24 * 5).Unix()
                issuer = "weblink_refresh"
        }</span>

        // Create the Claims
        <span class="cov8" title="1">claims := MyCustomClaims{
                uidText,
                jwt.StandardClaims{
                        ExpiresAt: timeExpiry, // access token will expire in 24h after creating
                        Issuer:    issuer,
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        ss, err := token.SignedString(mySigningKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        //fmt.Printf("%v %v", ss, err)
        <span class="cov8" title="1">return ss, nil</span>
        //Output: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJleHAiOjE1MDAwLCJpc3MiOiJ0ZXN0In0.HE7fK0xOQwFEr4WDgRWj4teRPZ6i3GLwD5YCm6Pwu_c &lt;nil&gt;
}

// JWTCheckMiddleware - check for authorization and json flag
func JWTCheckMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{

                if r.RequestURI == "/user/auth" </span><span class="cov8" title="1">{
                        //bypass jwt check when authenticating
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov8" title="1">re := regexp.MustCompile(`/shortopen/`)
                res := re.FindStringSubmatch(r.RequestURI)
                if len(res) != 0 </span><span class="cov8" title="1">{
                        //bypass jwt check when authenticating
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov8" title="1">authHeader := strings.Split(r.Header.Get("Authorization"), "Bearer ")

                if len(authHeader) != 2 </span><span class="cov0" title="0">{
                        ResponseAPIError(w, 2, http.StatusUnauthorized)
                        return
                }</span>

                // get jwtToken
                <span class="cov8" title="1">jwtToken := authHeader[1]
                token, err := jwt.Parse(jwtToken, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Unexpected signing method: %v", token.Header["alg"])
                        }</span>
                        <span class="cov8" title="1">SECRETKEY := "AllYourBase"
                        return []byte(SECRETKEY), nil</span>
                })

                <span class="cov8" title="1">if token.Valid </span><span class="cov8" title="1">{
                        if claims, ok := token.Claims.(jwt.MapClaims); ok &amp;&amp; token.Valid </span><span class="cov8" title="1">{
                                ctx := context.WithValue(r.Context(), ctxKey{}, claims)

                                if r.RequestURI != "/token/refresh" </span><span class="cov8" title="1">{
                                        // allow access to all API nodes with access token
                                        iss := fmt.Sprintf("%v", claims["iss"])
                                        if iss == "weblink_access" </span><span class="cov8" title="1">{
                                                next.ServeHTTP(w, r.WithContext(ctx))
                                                return
                                        }</span>
                                } else<span class="cov8" title="1"> {
                                        //allow only refresh tokens to go to /token/refresh endpoint
                                        //check type of token iss should be weblink_refresh
                                        iss := fmt.Sprintf("%v", claims["iss"])
                                        if iss == "weblink_refresh" </span><span class="cov8" title="1">{
                                                next.ServeHTTP(w, r.WithContext(ctx))
                                                return
                                        }</span>
                                        <span class="cov8" title="1">ResponseAPIError(w, 7, http.StatusUnauthorized)
                                        return</span>
                                }

                        } else<span class="cov0" title="0"> {
                                log.Printf("%v \n", err)
                                ResponseAPIError(w, 2, http.StatusUnauthorized)
                                return
                        }</span>

                } else<span class="cov0" title="0"> if ve, ok := err.(*jwt.ValidationError); ok </span><span class="cov0" title="0">{
                        if ve.Errors&amp;(jwt.ValidationErrorExpired|jwt.ValidationErrorNotValidYet) != 0 </span><span class="cov0" title="0">{
                                log.Printf("Token is either expired or not active yet %v", err)
                                ResponseAPIError(w, 1, http.StatusUnauthorized)
                                return
                        }</span>
                }

                <span class="cov0" title="0">ResponseAPIError(w, 3, http.StatusUnauthorized)</span>
        })
}
</pre>

		<pre class="file" id="file2" style="display: none">package endpoint

import (
        "fmt"
        "net/http"

        "github.com/dgrijalva/jwt-go"
        "github.com/gorilla/mux"
)

// GetUserStorageKeys - get all keys for this user in repo
func GetUserStorageKeys(request *http.Request, linkSvc linkSvc) ([]string, string, error) <span class="cov8" title="1">{
        props, _ := request.Context().Value(ctxKey{}).(jwt.MapClaims)
        //fmt.Println(props["uid"])
        UID := fmt.Sprintf("%v", props["uid"])

        storageKeys, err := linkSvc.List(UID)
        return storageKeys, UID, err
}</span>

// ValidateRequestShortLink - валидация shortlink параметра в request
// Возвращает саму ссылку, юзерайди (из токена), результат - тру - валидно
// инвалидно - результ - фалз, и все пустое.
func ValidateRequestShortLink(request *http.Request, linkSvc linkSvc) (string, string, bool) <span class="cov8" title="1">{

        storageKeys, UID, err := GetUserStorageKeys(request, linkSvc)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", false
        }</span>

        <span class="cov8" title="1">params := mux.Vars(request)
        shortURL := params["shortlink"]

        for _, storageKey := range storageKeys </span><span class="cov8" title="1">{
                if storageKey == shortURL </span><span class="cov8" title="1">{
                        return UID, storageKey, true
                }</span>
        }

        <span class="cov0" title="0">return "", "", false</span>
}
</pre>

		<pre class="file" id="file3" style="display: none">package endpoint

import (
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "time"

        "github.com/pehks1980/go_gb_be1_kurs/web-link/internal/pkg/model"

        "github.com/dgrijalva/jwt-go"
        "github.com/gorilla/mux"
)

//  linkSvc - интерфейс сервиса со стороны http
//  также имеет put get del crud - для работы с файлохранилищем
//  list - list all links for uid user
//  GetUn - open link for redir and add 1 to redir count
type linkSvc interface {
        Get(uid, key string) (model.DataEl, error)
        Put(uid, key string, value model.DataEl) error
        Del(uid, key string) error
        List(uid string) ([]string, error)
        GetUn(shortlink string) (model.DataEl, error)
}

// RegisterPublicHTTP - регистрация роутинга путей типа urls.py для обработки сервером
func RegisterPublicHTTP(linkSvc linkSvc) *mux.Router <span class="cov8" title="1">{
        // mux golrilla почему он? не знаю, - прикольное название, простота работы..
        r := mux.NewRouter()
        // JWT authorization
        r.HandleFunc("/user/auth", postAuth(linkSvc)).Methods(http.MethodPost)
        r.HandleFunc("/token/refresh", postTokenRefresh(linkSvc)).Methods(http.MethodPost)
        // Main function
        r.HandleFunc("/shortopen/{shortlink}", getShortOpen(linkSvc)).Methods(http.MethodGet)
        r.HandleFunc("/shortstat/{shortlink}", getShortStat(linkSvc)).Methods(http.MethodGet)
        // Links crud
        r.HandleFunc("/links", postToLink(linkSvc)).Methods(http.MethodPost)
        r.HandleFunc("/links/all", getFromLink(linkSvc)).Methods(http.MethodGet)
        r.HandleFunc("/links/{shortlink}", putToLink(linkSvc)).Methods(http.MethodPut)
        r.HandleFunc("/links/{shortlink}", delFromLink(linkSvc)).Methods(http.MethodDelete)
        // MiddleWare first goes JWT second goes Logging
        r.Use(JWTCheckMiddleware)
        r.Use(LoggingMiddleware)
        return r
}</span>

// postTokenRefresh - get new pair of jwt tokens when access token is expired
func postTokenRefresh(svc linkSvc) func(http.ResponseWriter, *http.Request) <span class="cov8" title="1">{
        return func(w http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                type TokenAnswer struct {
                        Access  string `json:"accessToken"`
                        Refresh string `json:"refreshToken"`
                }

                props, _ := request.Context().Value(ctxKey{}).(jwt.MapClaims)

                UID := fmt.Sprintf("%v", props["uid"])

                /*
                        Issuer := fmt.Sprintf("%v", props["iss"])

                        if Issuer != "weblink_refresh" {
                                ResponseAPIError(w, 7, http.StatusBadRequest)
                                return
                        }
                */
                tokenAccess, _ := GenJWTWithClaims(UID, 0)
                tokenRefresh, _ := GenJWTWithClaims(UID, 1)

                var jsonTokens = TokenAnswer{
                        Access:  tokenAccess,
                        Refresh: tokenRefresh,
                }

                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusOK)
                err := json.NewEncoder(w).Encode(jsonTokens)

                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

        }
}

// postAuth - autheticate and give authorization token
func postAuth(svc linkSvc) func(http.ResponseWriter, *http.Request) <span class="cov8" title="1">{
        return func(w http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                //json header check
                contentType := request.Header.Get("Content-Type")
                if contentType != "application/json" </span><span class="cov0" title="0">{
                        ResponseAPIError(w, 9, http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">type TokenAnswer struct {
                        Access  string `json:"accessToken"`
                        Refresh string `json:"refreshToken"`
                }

                type PostJSONRq struct {
                        UID string `json:"uid"`
                }

                var jsonPostRq = PostJSONRq{}

                err := json.NewDecoder(request.Body).Decode(&amp;jsonPostRq)
                if err != nil </span><span class="cov0" title="0">{
                        ResponseAPIError(w, 400, http.StatusBadRequest)
                        return
                }</span>
                // get uid
                <span class="cov8" title="1">if jsonPostRq.UID == "" </span><span class="cov0" title="0">{
                        ResponseAPIError(w, 8, http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">tokenAccess, _ := GenJWTWithClaims(jsonPostRq.UID, 0)
                tokenRefresh, _ := GenJWTWithClaims(jsonPostRq.UID, 1)

                var jsonTokens = TokenAnswer{
                        Access:  tokenAccess,
                        Refresh: tokenRefresh,
                }

                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusOK)
                err = json.NewEncoder(w).Encode(jsonTokens)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">return</span>

        }
}

// delFromLink deletes link from api storage by shortlink
func delFromLink(linkSvc linkSvc) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{

                UID, storageKey, res := ValidateRequestShortLink(request, linkSvc)
                if !res </span><span class="cov0" title="0">{
                        ResponseAPIError(w, 4, http.StatusBadRequest)
                        return
                }</span>

                //found key, delete it
                <span class="cov8" title="1">err := linkSvc.Del(UID, storageKey)
                if err != nil </span><span class="cov0" title="0">{
                        ResponseAPIError(w, 10, http.StatusBadRequest)
                        return
                }</span>

        }
}

// putToLink updates link from api storage
func putToLink(linkSvc linkSvc) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                //json header check
                contentType := request.Header.Get("Content-Type")
                if contentType != "application/json" </span><span class="cov0" title="0">{
                        ResponseAPIError(w, 9, http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">var element = model.DataEl{}
                w.Header().Set("Content-Type", "application/json")

                UID, _, res := ValidateRequestShortLink(request, linkSvc)
                if !res </span><span class="cov0" title="0">{
                        ResponseAPIError(w, 9, http.StatusBadRequest)
                        return
                }</span>
                //found key, work with body
                <span class="cov8" title="1">err := json.NewDecoder(request.Body).Decode(&amp;element)
                if err != nil </span><span class="cov0" title="0">{
                        ResponseAPIError(w, 9, http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">element.Datetime = time.Now()
                element.UID = UID
                element.Active = 1
                //looks ok, update storage
                err = linkSvc.Put(UID, element.Shorturl, element)
                if err != nil </span><span class="cov0" title="0">{
                        ResponseAPIError(w, 9, http.StatusBadRequest)
                }</span>
                // form answer json
                <span class="cov8" title="1">err = json.NewEncoder(w).Encode(element)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">return</span>
        }
}

// postToLink - creates new item in api storage
func postToLink(linkSvc linkSvc) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                //json header check
                contentType := request.Header.Get("Content-Type")
                if contentType != "application/json" </span><span class="cov0" title="0">{
                        ResponseAPIError(w, 9, http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">var element = model.DataEl{}
                w.Header().Set("Content-Type", "application/json")

                storageKeys, UID, err := GetUserStorageKeys(request, linkSvc)
                if err != nil </span><span class="cov0" title="0">{
                        ResponseAPIError(w, 10, http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">err = json.NewDecoder(request.Body).Decode(&amp;element)
                if err != nil </span><span class="cov0" title="0">{
                        ResponseAPIError(w, 9, http.StatusBadRequest)
                        return
                }</span>
                // check if we have key
                <span class="cov8" title="1">if element.Shorturl == "" </span><span class="cov0" title="0">{
                        ResponseAPIError(w, 11, http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">element.Datetime = time.Now()
                // check if this key already exists
                for _, storageKey := range storageKeys </span><span class="cov0" title="0">{
                        if storageKey == element.Shorturl </span><span class="cov0" title="0">{
                                ResponseAPIError(w, 5, http.StatusBadRequest)
                                return
                        }</span>
                }
                <span class="cov8" title="1">element.UID = UID
                element.Active = 1
                err = linkSvc.Put(UID, element.Shorturl, element)
                if err != nil </span><span class="cov0" title="0">{
                        ResponseAPIError(w, 10, http.StatusBadRequest)
                }</span>
                <span class="cov8" title="1">w.WriteHeader(http.StatusCreated) // this has to be the first write!!!
                err = json.NewEncoder(w).Encode(element)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">return</span>

        }
}

// getFromLink - get links list in json
func getFromLink(linkSvc linkSvc) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                w.Header().Set("Content-Type", "application/json")
                var datajson = model.Data{}

                storageKeys, UID, err := GetUserStorageKeys(request, linkSvc)
                if err != nil </span><span class="cov0" title="0">{
                        ResponseAPIError(w, 10, http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">for _, storageKey := range storageKeys </span><span class="cov8" title="1">{
                        getElement, errfor := linkSvc.Get(UID, storageKey)
                        if errfor != nil </span><span class="cov0" title="0">{
                                ResponseAPIError(w, 10, http.StatusBadRequest)
                                return
                                //http.Error(w, "Cannot read from repo", http.StatusBadRequest)
                        }</span>

                        <span class="cov8" title="1">datajson.Data = append(datajson.Data, getElement)</span>
                }

                <span class="cov8" title="1">err = json.NewEncoder(w).Encode(datajson)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

        }
}

// getShortStat - get one link from api
func getShortStat(linkSvc linkSvc) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                var datajson = model.Data{}
                // check user authorization, get user UID, get key (for this user, check if key exists)
                // if res - yes then do the action  - give string from repo as json
                UID, storageKey, res := ValidateRequestShortLink(request, linkSvc)
                if !res </span><span class="cov0" title="0">{
                        ResponseAPIError(w, 11, http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">getElement, err := linkSvc.Get(UID, storageKey)
                if err != nil </span><span class="cov0" title="0">{
                        ResponseAPIError(w, 10, http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">datajson.Data = append(datajson.Data, getElement)
                err = json.NewEncoder(w).Encode(datajson)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
}

// getShortOpen - get link opened (unonimously)
func getShortOpen(linkSvc linkSvc) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                // get data
                // update data
                // redir to real link

                params := mux.Vars(request)
                shortURL := params["shortlink"]
                // GetUn retreives link and updates redir count
                getElement, err := linkSvc.GetUn(shortURL)
                if err != nil </span><span class="cov0" title="0">{
                        ResponseAPIError(w, 10, http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">log.Printf("opening user %s link  %s (short is %s) redirs(++) %d \n", getElement.UID, getElement.URL, getElement.Shorturl, getElement.Redirs)
                http.Redirect(w, request, getElement.URL, http.StatusSeeOther)
                //&lt;a href="/shortopen/www.mail.ru"&gt;See Other&lt;/a&gt;.
                return</span>

        }
}
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
